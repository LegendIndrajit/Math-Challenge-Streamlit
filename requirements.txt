import random
import time
from datetime import datetime
import json
import os
import sys

SCORE_FILE = "math_scores.json"
MAX_STAGES = 3
LEVELS_PER_STAGE = 3

class MathGame:
    def __init__(self):
        self.player = {}
        self.scores = self.load_scores()
        self.current_stage = 1
        self.level_score = 0
        self.total_score = 0
        self.perfect_levels = 0

    def load_scores(self):
        if os.path.exists(SCORE_FILE):
            with open(SCORE_FILE, 'r') as f:
                try:
                    return json.load(f)
                except json.JSONDecodeError:
                    return []
        return []

    def save_score(self):
        self.scores.append({
            "name": self.player["name"],
            "class": self.player.get("class", ""),
            "school": self.player.get("school", ""),
            "score": self.total_score,
            "perfect_levels": self.perfect_levels,
            "date": datetime.now().strftime("%Y-%m-%d")
        })
        with open(SCORE_FILE, 'w') as f:
            json.dump(self.scores, f, indent=2)

    def clear_screen(self):
        print("\n" * 50)

    def register_player(self):
        self.clear_screen()
        print("\nMATH MASTER CHALLENGE")
        print("----------------------")
        
        self.player["name"] = input("Enter your name: ").strip().title()
        while not self.player["name"]:
            print("Name cannot be empty!")
            self.player["name"] = input("Enter your name: ").strip().title()
            
        self.player["class"] = input("Your class/grade: ").strip() or "N/A"
        input("\nPress ENTER to begin...")

    def generate_question(self, stage, level):
        """Generate math questions with adaptive time limits"""
        time_limits = {
            1: {1: 8, 2: 10, 3: 12},   # Easy levels - shorter time
            2: {1: 15, 2: 18, 3: 20},  # Medium levels
            3: {1: 22, 2: 25, 3: 28}   # Hard levels - longer time
        }
        
        operations = ['+', '-']
        if stage >= 1 and level >= 2:
            operations.append('*')
        if stage >= 2 or (stage == 1 and level == 3):
            operations.append('/')
            if random.random() < 0.3:  # 30% chance for decimals in division
                a = round(random.uniform(1, 10), 1)
                b = round(random.uniform(1, 5), 1)
                answer = round(a / b, 2)
                return f"{a} ÷ {b}", answer, time_limits[stage][level]
        
        num_range = [
            (1, 10), (5, 20), (10, 30),  # Stage 1
            (10, 50), (20, 70), (30, 100),  # Stage 2
            (50, 100), (70, 150), (100, 200)  # Stage 3
        ][(stage-1)*3 + (level-1)]
        
        a = random.randint(*num_range)
        b = random.randint(*num_range)
        
        if random.random() < 0.2 and stage > 1:  # 20% chance for decimals in +-*
            a = round(a * 0.1, 1)
            b = round(b * 0.1, 1)
        
        operation = random.choice(operations)
        
        if operation == '/':
            if b == 0:
                b = 1
            answer = round(a / b, 2)
            question = f"{a} ÷ {b}"
        else:
            answer = eval(f"{a}{operation}{b}")
            question = f"{a} {operation} {b}"
        
        return question, answer, time_limits[stage][level]

    def run_level(self, stage, level):
        self.clear_screen()
        correct = 0
        questions = 10 if stage < 3 else 12
        
        print(f"\nSTAGE {stage} - LEVEL {level}")
        print(f"Target: {int(questions*0.8)}/{questions} correct to advance\n")
        
        for q in range(1, questions + 1):
            question, answer, time_limit = self.generate_question(stage, level)
            print(f"\nQuestion {q}/{questions}")
            print(f"⏱️ Time limit: {time_limit}s")
            print(f"{question}")
            
            start = time.time()
            try:
                user_input = input("Your answer: ").strip()
                if user_input.lower() == 'exit':
                    return False
            except:
                return False
            
            elapsed = time.time() - start
            
            try:
                user_answer = float(user_input)
                if abs(user_answer - answer) < 0.01:  # Account for floating point errors
                    time_bonus = max(0, (time_limit - elapsed)) * (stage * 0.5)
                    points = (stage * 10) + int(time_bonus)
                    self.level_score += points
                    correct += 1
                    
                    remaining = max(0, time_limit - elapsed)
                    print(f"✅ Correct! +{points} points ({remaining:.1f}s remaining)")
                    
                    if remaining < time_limit * 0.25:
                        print("⚡ Speed bonus!")
                else:
                    print(f"❌ Incorrect. The answer was {answer}")
            except ValueError:
                print(f"⚠️ Please enter numbers only. The answer was {answer}")
            
            time.sleep(1)
        
        accuracy = correct / questions
        print(f"\nLevel {level} Results:")
        print(f"Score: {self.level_score}")
        print(f"Accuracy: {accuracy:.0%}")
        
        if accuracy >= 0.8:
            self.total_score += self.level_score
            self.level_score = 0
            if correct == questions:
                self.perfect_levels += 1
            return True
        return False

    def show_leaderboard(self):
        self.clear_screen()
        print("🏆 LEADERBOARD 🏆")
        print("Rank | Name | Score | Perfect Levels | Date")
        
        sorted_scores = sorted(self.scores, key=lambda x: x["score"], reverse=True)[:10]
        
        for idx, entry in enumerate(sorted_scores, 1):
            print(f"{idx}. {entry['name']} | {entry['score']} | {entry['perfect_levels']}/9 | {entry['date']}")
        
        input("\nPress ENTER to continue...")

    def grand_finale(self):
        self.save_score()
        self.clear_screen()
        
        rank = "Calculator Apprentice"
        if self.total_score > 300:
            rank = "Math Wizard 🧙"
        elif self.total_score > 200:
            rank = "Number Ninja 🥷"
        elif self.total_score > 100:
            rank = "Quick Calculator ⚡"
        
        print(f"""
        ╔══════════════════════════════════╗
        ║         🎉 CONGRATULATIONS! 🎉    ║
        ╠══════════════════════════════════╣
        ║ You've completed all 3 stages!  ║
        ║                                 ║
        ║ Title: {rank.center(20)} ║
        ║                                 ║
        ║ • Total Score: {self.total_score}       ║
        ║ • Perfect Levels: {self.perfect_levels}/9     ║
        ║                                 ║
        ║ View your score on the leader-  ║
        ║ board next time you play!       ║
        ║                                 ║
        ║         Made by INDRAJIT        ║
        ╚══════════════════════════════════╝
        """)

    def run_game(self):
        self.register_player()
        
        while self.current_stage <= MAX_STAGES:
            print(f"\n🌟 Stage {self.current_stage} Begins!")
            
            for level in range(1, LEVELS_PER_STAGE + 1):
                if not self.run_level(self.current_stage, level):
                    retry = input("\nTry again? (y/n): ").lower()
                    if retry != 'y':
                        print("\nThanks for playing!")
                        return
                    continue
                
                print("\nLevel completed!")
                if level < LEVELS_PER_STAGE:
                    input("Press ENTER to continue...")
            
            self.current_stage += 1
        
        self.grand_finale()
        input("\nPress ENTER to exit...")

if __name__ == "__main__":
    game = MathGame()
    game.run_game()

